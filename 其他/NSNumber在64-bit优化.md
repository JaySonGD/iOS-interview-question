##NSNumber在64-bit下的优化

####64bit-tagged pointer

*	指针地址对齐：分配堆中的内存时，采用偶数倍或者以2为指数倍的内存地址为边界
*	iOS中是以16个字节为对齐边界的。所以分配的内存地址后面4位永远都是0
*	64位理论上可以支持最大的2^64字节内存地址空间。这么大的地址空间完全是浪费的。64位环境下内存地址前面有很多个0
*	`Tagged Pointer` 指针地址对齐和64位超大地址的出现，指针地址仅仅作为内存地址是比较浪费的，可以在指针地址中保存更多的信息。 所以就有了Tagged Pointer概念。
	*	NSNumber是Tagged Pointer比较典型的应用，对于`一般`的数字，NSNumber不再分配内存了
	
	```
	NSNumber *number1 = @1;
    NSNumber *number2 = @2;
    NSNumber *number3 = @3;
    
    NSLog(@"number1 %p",number1);
    NSLog(@"number2 %p",number2);
    NSLog(@"number3 %p",number3);
	```
	打印的结果是：
	
	```
	2015-04-23 09:01:11.759 runtimeDEMO[616:10530] number1 0xb000000000000012
	2015-04-23 09:01:11.760 runtimeDEMO[616:10530] number2 0xb000000000000022
	2015-04-23 09:01:11.760 runtimeDEMO[616:10530] number3 0xb000000000000032
	```
	
	可以看见后面4位都是0x2,中间就是实际的取值。因此这些NSNumber已经不需要再分配内存了，直接可以把实际的值保存到指针中去，无需再去访问堆中的数据，所以这样做可以提高内存访问的速度和整体运算的速度。
	
	*如果超过了tagged pointer所能表示的范围，系统会怎么处理呢？
	
	```
		NSNumber *number = @(0x1234567890ABCDEF);
   		 NSLog(@"number %p",number);
	```
	结果是：
	
	```
	2015-04-23 09:07:59.445 runtimeDEMO[667:13259] number 0x7ffba1e726a0
	```
	可以发现自动采用分配成对象，可以根据指针的最后4位是否为0来区分
	
	
####isa指针的优化

所有的类继承自NSObject，因此每个对象都有一个isa指针指向它所属的类。

在32位环境下，对象的引用都保存在外部的表中，对引用计数的增减操作都需要锁定这个表，操作完后才解锁，这样效率是很慢的。

在64位环境下，isa也是64-bit的，实际操作部分只用到32位，剩余部分会用到tagged pointer的概念，其中19位将保存对象的引用计数，这样引用计数的操作只需要原子的修改这个指针即可，如果超出19位，才会将引用计数保存到外部表，这种情况是很少的，因此效率会大大提高。
	
	